"""
Handy middleware (Django compatible) and decorators.

"""

from django.core.exceptions import ObjectDoesNotExist
from django.db              import IntegrityError
from django.http            import HttpResponse, Http404
from donomo.archive.utils.http import HttpRequestValidationError
try:
    import json
except:
    import simplejson as json
import httplib
import traceback
import logging
import sys

#
# pylint: disable-msg=C0103,W0142
#
#   C0103 - variables at module scope must be all caps
#   W0142 - use of * and ** magic
#

logging = logging.getLogger('middleware')


JSON_CONTENT_TYPE  = 'text/plain'
XML_CONTENT_TYPE   = 'application/xml'
AJAX_CONTENT_TYPES = ( JSON_CONTENT_TYPE, XML_CONTENT_TYPE)

# ----------------------------------------------------------------------------

def json_view( view_func ):
    """
    Adapts a view function returning a dictionary into a normal
    Django view.  If the dictionary has a key called

    """
    def wrapper( request, *args, **kwargs ):
        """
        The resulting view func

        """
        response = view_func(request, *args, **kwargs)
        assert isinstance( response, dict ), \
            'json_view decorated view functions must return a dict'

        status = response.setdefault('status', httplib.OK)
        assert isinstance( status, int), \
            'status key in dict returned from a json_view view must be an int'

        return HttpResponse(
            content      = json.dumps( response ),
            status       = status,
            content_type = JSON_CONTENT_TYPE )

    return wrapper

# ----------------------------------------------------------------------------

class AjaxErrorHandlingMiddleware(object):
    """
    Middleware class to handle error occuring in API views (i.e., those
    generated by an XmlHttpRequest [read AJAX] from the client.

    """

    #  -  -   -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    if __debug__:
        @staticmethod
        def process_response( request, response ):
            """
            Make sure responses to AJAX requests have the 'right' content
            type.

            """
            if request.is_ajax():
                content_type = response['Content-Type']
                assert content_type in AJAX_CONTENT_TYPES, \
                    'Bad AJAX response type (%s); expected [%s]' \
                    % ( content_type, ','.join(AJAX_CONTENT_TYPES))
            return response

    #  -  -   -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    @staticmethod
    def process_exception( request, exception ):
        """
        Translate exceptions into JSON error responses.

        """

        if not request.is_ajax() \
                or isinstance(exception, KeyboardInterrupt):
            return None

        #
        # Figure out the error messages
        #

        if hasattr(exception, 'messages'):
            #
            # Django's ValidationError and CriticalValidationError exceptions
            #
            messages = exception.messages

        elif hasattr(exception, 'message'):
            #
            # Most other exception only have a single message
            #
            messages = [ exception.message ]

        else:
            #
            # Otherwise we just turn the exception into a string
            #
            messages = [ 'Internal error: %s' % exception ]

        #
        # Figure out the status code
        #

        if isinstance(exception, ObjectDoesNotExist) \
                or isinstance(exception, Http404):
            #
            # We'll turn failed db looks into not found errors
            #

            status = httplib.NOT_FOUND

        elif isinstance(exception, IntegrityError):
            #
            # Let's turn IntegretyErrors (example, you try to insert
            # a duplicate object into the db) as conflicts.
            #

            status = httplib.CONFLICT

        elif ( isinstance(exception, KeyError)
               or isinstance(exception, ValueError)
               or isinstance(exception, HttpRequestValidationError)
#               or isinstance(exception, CriticalValidationError)
              ):
            #
            # Let's interpret all data errors (invalid key lookups,
            # value conversion, validation) as bad requests.
            #

            status = httplib.BAD_REQUEST

        else:

            #
            # An unexpected error occurred.  Set the status, but also
            # log the error.  Only log the request in debug mode, as it
            # might contain confidential info.
            #

            status   = httplib.INTERNAL_SERVER_ERROR
            exc_info = sys.exc_info()
            logging.error(
                'Internal Error - Traceback Info:\n    %s',
                '\n    '.join(traceback.format_exception(*exc_info)))
            logging.debug(
                'Internal Error - Request Info:\n    %s',
                '\n    '.join(repr(request).split('\n')))

        #
        # Return a JSON response
        #

        response_dict = {
            'status'   : status,
            'messages' : messages,
            }

        return HttpResponse(
            content      = json.dumps( response_dict ),
            status       = status,
            content_type = JSON_CONTENT_TYPE )

# ----------------------------------------------------------------------------
