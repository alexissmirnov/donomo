"""
Handy middleware (Django compatible) and decorators.

"""


from django.conf                    import settings
from django.contrib.auth            import REDIRECT_FIELD_NAME
from django.contrib.auth.decorators import user_passes_test
from django.core.exceptions         import ObjectDoesNotExist
from django.db                      import IntegrityError
from django.http                    import HttpResponse, Http404, HttpResponseForbidden, HttpResponseRedirect
from django.utils.http              import urlquote
from donomo.archive.utils.http      import HttpRequestValidationError
from functools import update_wrapper
import httplib
import logging
import pprint
import sys
import time
import traceback
try:
    import json
except:
    import simplejson as json


#
# pylint: disable-msg=C0103,W0142
#
#   C0103 - variables at module scope must be all caps
#   W0142 - use of * and ** magic
#

logging = logging.getLogger('middleware')


JSON_CONTENT_TYPE  = 'text/plain'
SC_CONTENT_TYPE  = 'text/html'
SC_POST_CONTENT_TYPE  = 'text/html; charset=utf-8'
XML_CONTENT_TYPE   = 'application/xml'
AJAX_CONTENT_TYPES = ( JSON_CONTENT_TYPE, XML_CONTENT_TYPE, SC_CONTENT_TYPE, SC_POST_CONTENT_TYPE)

def api_login_required( view_func ):
    """
    Alternative to django's login_required decorator
    This one will return 403 (Forbidden) in response to an AJAX request, instead of
    redirecting the caller to a UI page
    """
    def wrapper( request, *args, **kwargs ):
        login_url = settings.LOGIN_URL
        redirect_field_name = REDIRECT_FIELD_NAME
        if request.user.is_authenticated():
            return view_func( request, *args, **kwargs )
        else:
            path = urlquote(request.get_full_path())
            if request.is_ajax():
                response = HttpResponseForbidden()
                response['Location'] = '%s?%s=%s' % (login_url, redirect_field_name, path)
            else:
                response = HttpResponseRedirect('%s?%s=%s' % (login_url, redirect_field_name, path))
        
            return response
    return wrapper


def long_poll( view_func ):
    """
    Delays the execution of the response by a number of seconds provided in timeout paramater.
    This is intended as a simplest implementation of the long polling feature for the API.
    """
    def wrapper( request, *args, **kwargs ):
        timeout = request.REQUEST.get('timeout', 0)
        time.sleep(float(timeout)/1000)
        response = view_func(request, *args, **kwargs)
        return response
    
    return wrapper
    
# ----------------------------------------------------------------------------

def json_view( view_func ):
    """
    Adapts a view function returning a dictionary into a normal
    Django view.  If the dictionary has a key called

    """
    def wrapper( request, *args, **kwargs ):
        """
        The resulting view func

        """
        response = view_func(request, *args, **kwargs)
        assert isinstance( response, dict ), \
            'json_view decorated view functions must return a dict'

        status = response.setdefault('status', httplib.OK)
        assert isinstance( status, int), \
            'status key in dict returned from a json_view view must be an int'

        return HttpResponse(
            content      = json.dumps( response ),
            status       = status,
            content_type = JSON_CONTENT_TYPE )

    return wrapper

# ----------------------------------------------------------------------------

class AjaxErrorHandlingMiddleware(object):
    """
    Middleware class to handle error occuring in API views (i.e., those
    generated by an XmlHttpRequest [read AJAX] from the client.

    """

    #  -  -   -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    if __debug__:
        @staticmethod
        def process_response( request, response ):
            """
            Make sure responses to AJAX requests have the 'right' content
            type.

            """
            if request.is_ajax():
                content_type = response['Content-Type']
                assert content_type in AJAX_CONTENT_TYPES, \
                    'Bad AJAX response type (%s); expected [%s]' \
                    % ( content_type, ','.join(AJAX_CONTENT_TYPES))
            return response

    #  -  -   -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    @staticmethod
    def process_exception( request, exception ):
        """
        Translate exceptions into JSON error responses.

        """

        if not request.is_ajax() \
                or isinstance(exception, KeyboardInterrupt):
            return None

        #
        # Figure out the error messages
        #

        if hasattr(exception, 'messages'):
            #
            # Django's ValidationError and CriticalValidationError exceptions
            #
            messages = exception.messages

        elif hasattr(exception, 'message'):
            #
            # Most other exception only have a single message
            #
            messages = [ exception.message ]

        else:
            #
            # Otherwise we just turn the exception into a string
            #
            messages = [ 'Internal error: %s' % exception ]

        #
        # Figure out the status code
        #

        if isinstance(exception, ObjectDoesNotExist) \
                or isinstance(exception, Http404):
            #
            # We'll turn failed db looks into not found errors
            #

            status = httplib.NOT_FOUND

        elif isinstance(exception, IntegrityError):
            #
            # Let's turn IntegretyErrors (example, you try to insert
            # a duplicate object into the db) as conflicts.
            #

            status = httplib.CONFLICT

        elif ( isinstance(exception, KeyError)
               or isinstance(exception, ValueError)
               or isinstance(exception, HttpRequestValidationError)
#               or isinstance(exception, CriticalValidationError)
              ):
            #
            # Let's interpret all data errors (invalid key lookups,
            # value conversion, validation) as bad requests.
            #

            status = httplib.BAD_REQUEST

        else:

            #
            # An unexpected error occurred.  Set the status, but also
            # log the error.  Only log the request in debug mode, as it
            # might contain confidential info.
            #

            status   = httplib.INTERNAL_SERVER_ERROR
            exc_info = sys.exc_info()
            logging.error(
                'Internal Error - Traceback Info:\n    %s',
                '\n    '.join(traceback.format_exception(*exc_info)))
            logging.debug(
                'Internal Error - Request Info:\n    %s',
                '\n    '.join(repr(request).split('\n')))

        #
        # Return a JSON response
        #

        response_dict = {
            'status'   : status,
            'messages' : messages,
            }

        return HttpResponse(
            content      = json.dumps( response_dict ),
            status       = status,
            content_type = JSON_CONTENT_TYPE )

# ----------------------------------------------------------------------------
