"""
Handy middleware (Django compatible) and decorators.

"""

from django.core.exceptions import ObjectDoesNotExist
from django.db              import IntegrityError
from django.http            import HttpResponse, Http404
import simplejson
import httplib
import traceback
import logging as logging_module
import sys

#
# pylint: disable-msg=C0103,W0142
#
#   C0103 - variables at module scope must be all caps
#   W0142 - use of * and ** magic
#

logging = logging_module.getLogger('middleware')


JSON_CONTENT_TYPE  = 'application/json'
XML_CONTENT_TYPE   = 'application/xml'
AJAX_CONTENT_TYPES = ( JSON_CONTENT_TYPE, XML_CONTENT_TYPE)

# ----------------------------------------------------------------------------

def json_view( view_func ):
    """
    Adapts a view function returning a dictionary into a normal
    Django view.  If the dictionary has a key called

    """
    def wrapper( request, *args, **kwargs ):
        """
        The resulting view func

        """
        response = view_func(request, *args, **kwargs)
        assert isinstance( response, dict ), \
            'json_view decorated view functions must return a dict'

        status = response.setdefault('status', httplib.OK)
        assert isinstance( status, int), \
            'status key in dict returned from a json_view view must be an int'

        return HttpResponse(
            content      = simplejson.dumps( response ),
            status       = status,
            content_type = JSON_CONTENT_TYPE )

    return wrapper

# ----------------------------------------------------------------------------

class AjaxErrorHandlingMiddleware(object):
    """
    Middleware class to handle error occuring in API views (i.e., those
    generated by an XmlHttpRequest [read AJAX] from the client.

    """

    #  -  -   -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    if __debug__:
        @staticmethod
        def process_response( request, response ):
            """
            Make sure responses to AJAX requests have the 'right' content
            type.

            """
            if request.is_ajax():
                content_type = response['Content-Type']
                assert content_type in AJAX_CONTENT_TYPES, \
                    'Bad AJAX response type (%s); expected [%s]' \
                    % ( content_type, ','.join(AJAX_CONTENT_TYPES))
            return None

    #  -  -   -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    @staticmethod
    def process_exception( request, exception ):
        """
        Translate exceptions into JSON error responses.

        """

        if not request.is_ajax() \
                or isinstance(exception, KeyboardInterrupt):
            return None

        #
        # Figure out the error message
        #

        if hasattr(exception, 'message'):
            message = exception.message
        else:
            message = 'Internal error: %s' % exception

        #
        # Figure out the status code
        #

        if isinstance(exception, ObjectDoesNotExist) \
                or isinstance(exception, Http404):
            #
            # We'll turn failed db looks into not found errors
            #

            status = httplib.NOT_FOUND

        elif isinstance(exception, IntegrityError):
            #
            # Let's turn IntegretyErrors (example, you try to insert
            # a duplicate object into the db) as conflicts.
            #

            status = httplib.CONFLICT

        elif isinstance(exception, KeyError):
            #
            # Let's interpret all key error (lookups in dictionaries)
            # as bad requests.  The usual scenario will be that the
            # view failed to find an expected parameter in the GET or
            # POST.
            #

            status = httplib.BAD_REQUEST

        else:

            #
            # An unexpected error occurred.  Set the status, but also
            # log the error.  Only log the request in debug mode, as it
            # might contain confidential info.
            #

            status   = httplib.INTERNAL_SERVER_ERROR
            exc_info = sys.exc_info()
            logging.error(
                'Internal Error - Traceback Info:\n    %s',
                '\n    '.join(traceback.format_exception(*exc_info)))
            logging.debug(
                'Internal Error - Request Info:\n    %s',
                '\n    '.join(repr(request).split('\n')))

        #
        # Return a JSON response
        #

        response_dict = {
            'status'  : status,
            'message' : message,
            }

        return HttpResponse(
            content      = simplejson.dumps( response_dict ),
            status       = status,
            content_type = JSON_CONTENT_TYPE )

# ----------------------------------------------------------------------------
